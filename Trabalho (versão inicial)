#include <iostream>
#include <vector>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <unistd.h>
#include <windows.h>
#include <time.h>
#include <algorithm>

int main()
{
    FILE *arquivo;
    char linha[256], *pch;
    unsigned int i, j, numero_vertices, numero_arestas, inteiro, vertice_aleatorio_um, vertice_aleatorio_dois;
    unsigned int arestas_corte = 0;
    std::vector<std::vector<unsigned int> > vertices;
    std::vector<std::vector<unsigned int> > subgrafo_um;
    std::vector<std::vector<unsigned int> > subgrafo_dois;
    std::vector<int>::iterator acha_aresta;
    //std::vector<bool>::size_type subgrafos = vertices.size(); //Se 1, pertence a A. Se 0, pertence a B.

    arquivo = fopen("add20.graph", "r");

    if (!arquivo)
    {
        printf ("Erro na abertura do arquivo.");
        return 0;
    }
    else
    {
        fgets(linha, sizeof(linha), arquivo);
        pch = strtok(linha, " ");
        std::cout << "Numero de vertices: " << pch << "\n";
        numero_vertices = atoi (pch); //Numero de vertices no grafo
        pch = strtok(NULL, " ");
        std::cout << "Numero de arestas: " << pch;
        numero_arestas = atoi (pch); //Numero de arestas no grafo
        for (i = 0; i < numero_vertices; i++) //Para cada vertice v
        {
            std::cout << "\nOs vizinhos de " << i+1 << " sao: ";
            std::vector<unsigned int>temp;
            fgets(linha, sizeof(linha), arquivo);
            pch = strtok(linha, " ");
            inteiro = atoi(pch);
            temp.push_back(inteiro);
            std::cout << inteiro << " ";
            Sleep(100);
            while (pch != NULL) //Indique os vizinhos do vertice v.
            {
                pch = strtok(NULL, " ");
                inteiro = atoi (pch);

                Sleep(100);
                if (inteiro != 0)
                {
                std::cout << inteiro << " ";
                    temp.push_back(inteiro);
                }
            }
            vertices.push_back(temp);
            temp.clear();
        }
/*
        for (i = 0; i < vertices.size(); i++)
        {
            std::cout << "O vertice " << i+1 << " tem vizinhos ";
            for (j = 0; j < vertices[i].size(); j++)
            {
                std::cout << vertices[i][j] << ", ";
                            Sleep(500);
            }
            std::cout << "\n";
        } */
    }
    fclose(arquivo);

    srand(time(NULL));

    do
    {
    vertice_aleatorio_um = rand() % vertices.size(); //Gera um numero aleatorio entre 0 e |V|-1
    vertice_aleatorio_dois = rand() % vertices.size(); //Gera um numero aleatorio entre 0 e |V|-1
    } while (vertice_aleatorio_um == vertice_aleatorio_dois); //vertices u e v devem ser distintos.

    subgrafo_um[vertice_aleatorio_um] = vertices[vertice_aleatorio_um]; //A <- u
    subgrafo_dois[vertice_aleatorio_dois] = vertices[vertice_aleatorio_dois]; //B <- v

    return 0;
}
//pch = strtok(NULL, " ");
//std::cout << "   " << pch;


//vertices.push_back(0);

//std::cout << "Vetor: ";
//std::cout << vertices[0] << " ";


